declareFunction x y z := x

declareFunction x y z :=
  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

longword := "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

verylongword :=
  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

assertEqual "aaaa"
  "aaa"
  "aa"
  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  "aaaa"
  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

(3 + 4) * (-1)

\x ->
  x + "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

match 1 as integer with
  | #1 & (#2 | #3) -> True

match 1 as integer with
  | #1 & #2 | #3 -> True

match 1 as integer with
  | #1 | #2 & #3 -> True

match 1 as integer with
  | (#1 | #2) & #3 -> True

match 1 as integer with
  | #1 & #2 & #3 -> True

match 1 as integer with
  | #1 :: _ | #2 | #3 -> True

assertEqual "char literal" 'a' 'a'

assertEqual "char literal" '\n' '\n'

assertEqual "string literal" "abc\n" "abc\n"

assertEqual "bool literal" (True, False) (True, False)

assertEqual "integer literal" (1, 0, -100, 1 + (-100)) (1, 0, -100, -99)

assertEqual "rational number"
  (10 / 3, 10 / 20, (-1) / 2)
  (10 / 3, 1 / 2, (-1) / 2)

assertEqual "float literal"
  (1.0, 0.0, -100.012001, 1.0 + 2)
  (1.0, 0.0, -100.012001, 3.0)

assertEqual "inductive data literal" A A

assertEqual "tuple literal" (1, 2, 3) (1, 2, 3)

assertEqual "singleton tuple literal" (1) 1

assertEqual "if" (if True then True else False) True

assertEqual "if" (if False then True else False) False

assertEqual "let binding"
  (let t := (1, 2)
    in let (x, y) := t
        in x + y)
  3

assertEqual "let* binding"
  (let x := 1
       y := x + 1
    in y)
  2

assertEqual "letrec binding"
  (let (x, y) := t
       t := (1, 2)
    in x + y)
  3

assertEqual "mutual recursion"
  (let even? n := if n = 0 then True else odd? (n - 1)
       odd? n := if n = 0 then False else even? (n - 1)
    in even? 10)
  True

assertEqual "lambda and application" ((\x -> 1 + x) 10) 11

assertEqual "placeholder" ((\:1 -> :1 + 1) 10) 11

assertEqual "indexed placeholder" ((\:1 -> :1 + :1) 10) 20

assertEqual "indexed placeholder2" ((\:1 :2 -> :2 - :1) 10 20) 10

assertEqual "match"
  (match 1 as integer with
    | #0 -> 0
    | $x -> 10 + x)
  11

assertEqual "match-all"
  (matchAll [1, 2, 3] as list integer with
    | $x :: $xs -> (x, xs))
  [(1, [2, 3])]

assertEqual "match-all-multi"
  (matchAll [1, 2, 3] as multiset integer with
    | $x :: #(x + 1) :: _ -> (x, x + 1)
    | $x :: #(x + 2) :: _ -> (x, x + 2))
  [(1, 2), (2, 3), (1, 3)]

assertEqual "match-lambda"
  (let count := \match as list something with
                  | [] -> 0
                  | _ :: $xs -> (count xs) + 1
    in count [1, 2, 3])
  3

assertEqual "match-all-lambda"
  ((\matchAll as list something with
       | _ ++ $x :: _ -> x) [1, 2, 3])
  [1, 2, 3]

assertEqual "match-all-lambda-multi"
  ((\matchAll as multiset something with
       | $x :: #(x + 1) :: _ -> (x, x + 1)
       | $x :: #(x + 2) :: _ -> (x, x + 2)) [1, 2, 3])
  [(1, 2), (2, 3), (1, 3)]

assertEqual "pattern variable"
  (match 1 as something with
    | $x -> x)
  1

assert "value pattern"
  (match 1 as integer with
    | #1 -> True)

assert "and pattern"
  (match [1, 2, 3] as list integer with
    | #1 :: _ & (snoc #3 _) -> True)

assert "and pattern"
  (match [1, 2, 3] as list integer with
    | #1 :: _ & #3 :: _ -> False
    | _ -> True)

assert "or pattern"
  (match [1, 2, 3] as list integer with
    | (snoc #1 _) | (snoc #3 _) -> True)

assert "or pattern"
  (match [1, 2, 3] as list integer with
    | #2 :: _ | #3 :: _ -> False
    | _ -> True)

assert "not pattern"
  (match 1 as integer with
    | !#1 -> False
    | !#2 -> True)

assertEqual "not pattern"
  (matchAll [1, 2, 2, 3, 3, 3] as multiset integer with
    | $n :: (!#n :: _) -> n)
  [1]

assert "predicate pattern"
  (match [1, 2, 3] as list integer with
    | ?(\:2 -> 1 = :2) :: _ -> True)

assert "predicate pattern"
  (match [1, 2, 3] as list integer with
    | ?(\:2 -> 2 = :2) :: _ -> False
    | _ -> True)

assertEqual "indexed pattern variable"
  (match 23 as mod 10 with
    | REPLACEME -> a)
  {|(1, 23)|}

assertEqual "seq pattern"
  (matchAll [1, 2, 3, 2, 4, 3, 5] as list integer with
    | REPLACEME -> x)
  [1, 2, 3, 4, 5]

assert "loop pattern"
  (match [3, 2, 1] as list integer with
    | REPLACEME -> True)

assertEqual "double loop pattern"
  (match [[1, 2, 3], [4, 5, 6], [7, 8, 9]] as list (list integer) with
    | REPLACEME -> n)
  {|(1, {|(1, 1), (2, 2), (3, 3)|})
  , (2, {|(1, 4), (2, 5), (3, 6)|})
  , (3, {|(1, 7), (2, 8), (3, 9)|})|}

assertEqual "let pattern"
  (match [1, 2, 3] as list integer with
    | let a := 42 in _ -> a)
  42

assertEqual "let pattern"
  (match [1, 2, 3] as list integer with
    | $a :: let x := a in $xs -> (x, xs))
  (1, [2, 3])

assertEqual "let pattern"
  (match [1, 2, 3] as list integer with
    | $a & let n := length a in _ -> (a, n))
  ([1, 2, 3], 3)

assertEqual "tuple patterns"
  (matchAll (1, (2, 3)) as (integer, (integer, integer)) with
    | ($m, ($n, $w)) -> (m, n, w))
  [(1, 2, 3)]

assertEqual "pattern function call"
  (let twin := \pat1 pat2 => cons REPLACEME cons #x REPLACEME
    in match [1, 1, 1, 2, 3] as list integer with
      | REPLACEME -> (n, ns))
  (1, [1, 2, 3])

assertEqual "recursive pattern function call"
  (let repeat := \pat => REPLACEME
    in match [1, 1, 1, 1] as list integer with
      | REPLACEME -> n)
  1

assertEqual "loop pattern in pattern function"
  (let comb n := \p => REPLACEME
    in matchAll [1, 2, 3, 4, 5] as list integer with
      | REPLACEME -> n)
  [ {|(1, 1), (2, 2)|}
  , {|(1, 1), (2, 3)|}
  , {|(1, 2), (2, 3)|}
  , {|(1, 1), (2, 4)|}
  , {|(1, 2), (2, 4)|}
  , {|(1, 3), (2, 4)|}
  , {|(1, 1), (2, 5)|}
  , {|(1, 2), (2, 5)|}
  , {|(1, 3), (2, 5)|}
  , {|(1, 4), (2, 5)|} ]

assertEqual "pairs of 2 natural numbers"
  (take 10
     (matchAll nats as set integer with
       | $m :: $n :: _ -> (m, n)))
  [ (1, 1)
  , (1, 2)
  , (2, 1)
  , (1, 3)
  , (2, 2)
  , (3, 1)
  , (1, 4)
  , (2, 3)
  , (3, 2)
  , (4, 1) ]

assertEqual "pairs of 2 different natural numbers"
  (take 10
     (matchAll nats as list integer with
       | _ ++ $m :: _ ++ $n :: _ -> (m, n)))
  [ (1, 2)
  , (1, 3)
  , (2, 3)
  , (1, 4)
  , (2, 4)
  , (3, 4)
  , (1, 5)
  , (2, 5)
  , (3, 5)
  , (4, 5) ]

tree a :=
  algebraicDataMatcher
    | leaf
    | node tree a a tree a

treeInsert n t :=
  match t as tree integer with
    | leaf -> Node Leaf n Leaf
    | node $t1 $m $t2 ->
      match compare n m as ordering with
        | less -> Node treeInsert n t1 m t2
        | equal -> Node t1 n t2
        | greater -> Node t1 m treeInsert n t2

treeMember? n t :=
  match t as tree integer with
    | leaf -> False
    | node $t1 $m $t2 ->
      match compare n m as ordering with
        | less -> treeMember? n t1
        | equal -> True
        | greater -> treeMember? n t2

assertEqual "tree set using algebraic-data-matcher"
  (let t := foldr treeInsert Leaf [4, 1, 2, 4, 3]
    in (treeMember? 1 t, treeMember? 0 t))
  (True, False)

assertEqual "tuple pattern"
  (matchAll [(1, 1), (2, 2)] as multiset (integer, integer) with
    | ($x, #x) :: _ -> x)
  [1, 2]

assertEqual "array-literal" (|1, 2, 3, 4, 5|) (|1, 2, 3, 4, 5|)

assertEqual "empty array literal" (||) (||)

assertEqual "array-bounds - case 1" (arrayBounds (|1, 2, 3|)) (1, 3)

assertEqual "array-bounds - case 2"
  (arrayBounds (generateArray (\:1 -> :1 + 100) (3, 5)))
  (3, 5)

assertEqual "array-ref" (arrayRef (|1, 2, 3, 4, 5|) 3) 3

assertEqual "generate-tensor - case 1"
  (generateTensor kroneckerDelta [3])
  [|1, 1, 1|]

assertEqual "generate-tensor - case 2"
  (generateTensor kroneckerDelta [2, 2, 2, 2])
  REPLACEME

assertEqual "hash-literal"
  {|(1, 11), (2, 12), (3, 13), (4, 14), (5, 15)|}
  {|(1, 11), (2, 12), (3, 13), (4, 14), (5, 15)|}

assertEqual "empty hash-literal" {||} {||}

assertEqual "hash access" REPLACEME 13

assertEqual "partial application '$'" ((\:1 :2 -> :1 + :2) 1 2) 3

assertEqual "partial application '$' with index" ((\:1 :2 -> :2 - :1) 1 2) 1

assertEqual "partial application '#'" (REPLACEME 1 2) 12

assertEqual "recursive partial application '#'"
  (take 10 (REPLACEME 2))
  [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]

assertEqual "double inverted index"
  (let f *x *y := x + y
    in (f REPLACEME REPLACEME))
  (REPLACEME)

assertEqual "single inverted index"
  (let f x *y := x + y
    in (f REPLACEME REPLACEME))
  (REPLACEME)
