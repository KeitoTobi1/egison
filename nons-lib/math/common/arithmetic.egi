--
-- This file has been auto-generated by egison-translator.
--

toMathExpr arg := mathNormalize1 (toMathExpr' arg)

+' := cambda xs -> foldl1 b.+ xs

-' := cambda xs -> foldl1 b.- xs

*' := cambda xs -> foldl1 b.* xs

/' := b./

f.+' := cambda xs -> foldl1 f.+ xs

f.-' := cambda xs -> foldl1 f.- xs

f.*' := cambda xs -> foldl1 f.* xs

f./' := f./

+ :=
  cambda xs ->
    if capply (||) (map float? xs)
      then capply f.+' (map (\x -> if float? x then x else itof x) xs)
      else mathNormalize1 (capply (+') xs)

- :=
  cambda xs ->
    if capply (||) (map float? xs)
      then capply f.-' (map (\x -> if float? x then x else itof x) xs)
      else mathNormalize1 (capply (-') xs)

* :=
  cambda xs ->
    if capply (||) (map float? xs)
      then capply f.*' (map (\x -> if float? x then x else itof x) xs)
      else mathNormalize1 (capply (*') xs)

/ x y :=
  if float? x && float? y
    then f./ x y
    else if float? x
      then f./ x (itof y)
      else if float? y then f./ (itof x) y else b./ x y

reduceFraction := id

sum xs := if empty? xs then 0 else capply (+) xs

sum' xs := foldl (+') 0 xs

product xs := if empty? xs then 1 else capply (*) xs

product' xs := foldl (*') 1 xs

power x n := mathNormalize1 (power' x n)

power' x n := foldl (*') 1 (take n (repeat1 x))

** x n :=
  if x = e
    then exp n
    else if rational? n
      then if n >= 0
        then if integer? n then power x n else `(^) x n
        else 1 / x ^ neg n
      else `(^) x n

**' x n :=
  if x = e
    then exp n
    else if rational? n
      then if n >= 0
        then if integer? n then power' x n else `(^) x n
        else 1 /' x ^' neg n
      else `(^) x n

gcd := cambda xs -> foldl1 b.gcd xs

gcd' := cambda xs -> foldl1 b.gcd' xs

b.gcd x y :=
  match (x, y) as (termExpr, termExpr) with
    | (_, #0) -> x
    | (#0, _) -> y
    | (term $a $xs, term $b $ys) ->
      b.gcd' (abs a) (abs b) *' foldl (*') 1 (map (^') (AC.intersect xs ys))

b.gcd' x y :=
  match (x, y) as (integer, integer) with
    | (_, #0) -> x
    | (#0, _) -> y
    | (_, ?1#(%1 >= x)) -> b.gcd' (modulo y x) x
    | (_, _) -> b.gcd' y x

P./ fx gx x :=
  let as := reverse (coefficients fx x)
      bs := reverse (coefficients gx x)
      (zs, rs) := L./ as bs
   in ( sum' (map2 2#(%1 *' x ^' %2) (reverse zs) nats0)
      , sum' (map2 2#(%1 *' x ^' %2) (reverse rs) nats0) )
