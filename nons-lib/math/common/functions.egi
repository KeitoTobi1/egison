--
-- This file has been auto-generated by egison-translator.
--

abs x := if rational? x then b.abs x else x

neg x := if rational? x then b.neg x else - x

exp x :=
  if float? x
    then b.exp x
    else if term? x
      then match x as termExpr with
        | #0 -> 1
        | #1 -> e
        | mult $a #(i * pi) -> (-1) ^ a
        | _ -> `exp x
      else `exp x

log x :=
  if float? x
    then b.log x
    else match x as mathExpr with
      | #1 -> 0
      | #e -> 1
      | _ -> `log x

cos x :=
  if float? x
    then b.cos x
    else match x as mathExpr with
      | #0 -> 1
      | term $n #π :: [] -> (-1) ^ abs n
      | div mult _ #π #2 -> 0
      | _ -> `cos x

sin x :=
  if float? x
    then b.sin x
    else match x as mathExpr with
      | #0 -> 0
      | mult _ #π -> 0
      | div mult $n #π #2 -> (-1) ^ ((abs n - 1) / 2)
      | _ -> `sin x

tan x :=
  if float? x
    then b.tan x
    else match x as mathExpr with
      | #0 -> 0
      | _ -> `tan x

cosh x :=
  if float? x
    then b.cosh x
    else match x as mathExpr with
      | #0 -> 1
      | _ -> `cosh x

sinh x :=
  if float? x
    then b.sinh x
    else match x as mathExpr with
      | #0 -> 0
      | _ -> `sinh x

tanh x :=
  if float? x
    then b.tanh x
    else match x as mathExpr with
      | #0 -> 0
      | _ -> `tanh x

sinc x :=
  if float? x
    then if x = 0.0 then 1.0 else b.sin x / x
    else match x as mathExpr with
      | #0 -> 1
      | _ -> sin x / x

sigmoid z := 1 / (1 + exp (- z))

kroneckerDelta := cambda js -> if all 1#(%1 = car js) (cdr js) then 1 else 0

eulerTotientFunction n := n * product (map (\p -> 1 - 1 / p) (unique (pF n)))

ε := REPLACEME

ε' := REPLACEME
