--
-- This file has been auto-generated by egison-translator.
--

mathNormalize1 x :=
  if integer? x
    then x
    else let ret := capply compose (map 2#%1 (filter 2#(%2 x) rewriteRules1)) x
          in ret

rewriteRules1 :=
  [ (id, 1#True)
  , (rewriteRuleForI, 1#(containSymbol? i %1))
  , (rewriteRuleForWTerm, 1#(containSymbol? w %1))
  , (rewriteRuleForRtuTerm, 1#(containFunction? `rtu %1))
  , (rewriteRuleFor**, 1#(containFunction? `(^) %1))
  , (rewriteRuleForExp, 1#(containFunction? `exp %1))
  , (rewriteRuleForWPoly, 1#(containSymbol? w %1))
  , (rewriteRuleForRtuPoly, 1#(containFunction? `rtu %1))
  , (rewriteRuleForSqrt, 1#(containFunction? `sqrt %1))
  , (rewriteRuleForRt, 1#(containFunction? `rt %1))
  , (rewriteRuleForCosToSin, 1#(containFunctionWithOrder? `cos 2 %1))
  , (rewriteRuleForD/d, 1#True) ]

rewriteRuleForI := rewriteRuleForITerm

rewriteRuleForITerm := 1#(mapTerms rewriteRuleForITerm' %1)

rewriteRuleForITerm' term :=
  match term as mathExpr with
    | REPLACEME -> *' a (**' (-1) (quotient k 2)) r
    | REPLACEME -> *' a (**' (-1) (quotient k 2)) r i
    | _ -> term

rewriteRuleForW := 1#(compose rewriteRuleForWTerm rewriteRuleForWPoly %1)

rewriteRuleForWTerm := 1#(mapTerms rewriteRuleForWTerm' %1)

rewriteRuleForWPoly := 1#(mapPolys rewriteRuleForWPoly' %1)

rewriteRuleForWTerm' term :=
  match term as mathExpr with
    | REPLACEME -> *' a r (**' w (k % 3))
    | _ -> term

rewriteRuleForWPoly' poly :=
  match poly as mathExpr with
    | REPLACEME -> rewriteRuleForWPoly' (+' pr (*' (-1) a mr) (*' (b - a) mr w))
    | _ -> poly

rewriteRuleForRtu :=
  compose
    1#(mapTerms rewriteRuleForRtuTerm %1)
    1#(mapPolys rewriteRuleForRtuPoly %1)

rewriteRuleForRtuTerm := 1#(mapTerms rewriteRuleForRtuTerm' %1)

rewriteRuleForRtuPoly := 1#(mapPolys rewriteRuleForRtuPoly' %1)

rewriteRuleForRtuTerm' term :=
  match term as mathExpr with
    | REPLACEME -> *' a (**' (rtu n) (k % n)) r
    | _ -> term

rewriteRuleForRtuPoly' poly :=
  match poly as mathExpr with
    | REPLACEME -> rewriteRuleForRtuPoly' (+' pr (*' (-1) a mr))
    | _ -> poly

rewriteRuleForSqrt := 1#(mapTerms rewriteRuleForSqrtTerm %1)

rewriteRuleForSqrtTerm term :=
  match term as mathExpr with
    | REPLACEME -> rewriteRuleForSqrt (*' a x r)
    | REPLACEME ->
      let d := gcd x y
          (a1, x1) := fromMonomial (x / d)
          (a2, y1) := fromMonomial (y / d)
       in *' a d (sqrt (*' a1 a2)) (sqrt x1) (sqrt y1) r
    | _ -> term

rewriteRuleForRt := 1#(mapTerms rewriteRuleForRtTerm %1)

rewriteRuleForRtTerm term :=
  match term as mathExpr with
    | REPLACEME -> *' a (**' x (quotient k n)) (**' (rt n x) (k % n)) r
    | _ -> term

rewriteRuleForExp := 1#(mapTerms rewriteRuleForExpTerm %1)

rewriteRuleForExpTerm term :=
  match term as mathExpr with
    | REPLACEME -> rewriteRuleForExp (*' a (exp (x * n)) r)
    | REPLACEME -> rewriteRuleForExp (*' a (exp (x + y)) r)
    | _ -> term

rewriteRuleFor** := 1#(mapTerms rewriteRuleFor**Term %1)

rewriteRuleFor**Term term :=
  match term as mathExpr with
    | REPLACEME -> rewriteRuleFor** (*' a r)
    | REPLACEME -> rewriteRuleFor** (*' a (x ^ (y * n)) r)
    | REPLACEME -> rewriteRuleFor** (*' a (x ^ (y + z)) r)
    | _ -> term

rewriteRuleForCosAndSin := 1#(mapPolys rewriteRuleForCosAndSinPoly %1)

rewriteRuleForCosAndSinExpr expr :=
  match (expr, expr) as (mathExpr, mathExpr) with
    | (div REPLACEME $pr2, (div REPLACEME _) | (div _ REPLACEME)) ->
      rewriteRuleForCosAndSinExpr
        (/' (+' (*' a (-' (cos (x / 2) ^ 2) (sin (x / 2) ^ 2)) mr) pr1) pr2)
    | (div REPLACEME $pr2, (div REPLACEME _) | (div _ REPLACEME)) ->
      rewriteRuleForCosAndSinExpr
        (/' (+' (*' (*' a 2) (*' (cos (x / 2)) (sin (x / 2))) mr) pr1) pr2)
    | (div $pr2 REPLACEME, (div REPLACEME _) | (div _ REPLACEME)) ->
      rewriteRuleForCosAndSinExpr
        (/' pr2 (+' (*' a (-' (cos (x / 2) ^ 2) (sin (x / 2) ^ 2)) mr) pr1))
    | (div $pr2 REPLACEME, (div REPLACEME _) | (div _ REPLACEME)) ->
      rewriteRuleForCosAndSinExpr
        (/' pr2 (+' (*' (*' a 2) (*' (cos (x / 2)) (sin (x / 2))) mr) pr1))
    | _ -> expr

rewriteRuleForCosAndSinPoly poly :=
  match poly as mathExpr with
    | REPLACEME -> rewriteRuleForCosAndSinPoly (+' pr (*' a mr))
    | REPLACEME -> rewriteRuleForCosAndSinPoly (+' pr (*' a (cos x ^ 2) mr))
    | REPLACEME -> rewriteRuleForCosAndSinPoly (+' pr (*' a (sin x ^ 2) mr))
    | _ -> poly

rewriteRuleForCosToSin := 1#(mapTerms rewriteRuleForCosToSinTerm' %1)

rewriteRuleForCosToSinTerm' term :=
  match term as mathExpr with
    | REPLACEME -> *' a (-' 1 (sin x ^ 2)) (rewriteRuleForCosToSinTerm' mr)
    | _ -> term

rewriteRuleForD := 1#(mapTerms rewriteRuleForDTerm %1)

rewriteRuleForDTerm term :=
  match term as mathExpr with
    | REPLACEME -> 0
    | _ -> term

rewriteRuleForD/d := 1#(mapPolys rewriteRuleForD/dPoly %1)

rewriteRuleForD/dPoly poly :=
  match poly as mathExpr with
    | REPLACEME -> rewriteRuleForD/dPoly (+' (*' (a + b) (f ^ n) mr) pr)
    | _ -> poly
