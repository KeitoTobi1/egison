;;;;;
;;;;;
;;;;; s.ring
;;;;;
;;;;;

(define $string
  (matcher
    {[<regex-cg ,$regexpr $ $ $> [string (list string) string]
      {[$tgt (regex-cg regexpr tgt)]}]
     [<regex ,$regexpr $ $ $> [string string string]
      {[$tgt (regex regexpr tgt)]}]
     [<nil> []
      {[$tgt (if (eq? "" tgt)
               {[]}
               {})]}]
     [<cons $ $> [char string]
      {[$tgt (if (eq? "" tgt)
               {}
               {(uncons-string tgt)})]}]
     [<join $ <cons ,$px $>> [string string]
      {[$tgt (match-all (s.split (pack {px}) tgt) (list string)
               [<join (& !<nil> $xs) (& !<nil> $ys)> [(s.intercalate (pack {px}) xs)
                                (s.intercalate (pack {px}) ys)
                                ]])]}]
     [<join $ <join ,$pxs $>> [string string]
      {[$tgt (match-all (s.split pxs tgt) (list string)
               [<join (& !<nil> $xs) (& !<nil> $ys)> [(s.intercalate pxs xs)
                                (s.intercalate pxs ys)
                                ]])]}]
     [<join $ $> [string string]
      {[$tgt (match-all tgt string
                 [(loop $i [1 $n] <cons $xa_i ...> $rs) [(pack (map (lambda [$i] xa_i) (between 1 n))) rs]])]}]
     [,$val []
      {[$tgt  (if (eq? val tgt)
                {[]}
                {})]}]
     [$ [something]
      {[$tgt {tgt}]}]
     }))

;;;
;;; s.ring as collection
;;;
(define $s.empty?
  (lambda [$xs]
    (eq? xs "")))

(define $s.cons
  (lambda [$x $xs]
    (append-string (pack {x}) xs)))

(define $s.car
  (lambda [$xs]
    (match xs string
      {[<cons $x _> x]})))

(define $s.cdr
  (lambda [$xs]
    (match xs string
      {[<cons _ $r> r]})))

(define $s.rac
  (lambda [$str]
    (match str string
      {[<join _ <cons $c <nil>>> c]})))

(define $s.map
  (lambda [$f $xs]
    (pack (map f (unpack xs)))))

(define $s.length
  (lambda [$xs]
    (length-string xs)))

(define $s.split
  (lambda [$in $ls]
    (split-string in ls)))

(define $s.append
  (lambda [$xs $ys]
    (append-string xs ys)))

(define $s.concat
  (lambda [$xss]
    (foldr (lambda [$xs $rs] (s.append xs rs))
           ""
           xss)))

(define $s.intercalate (compose intersperse s.concat))

(define $s.replace
  (lambda [$before $after $str]
    (s.intercalate after (s.split before str))))


;;
;; Alphabet
;;
(define $c.between
  (lambda [$c1 $c2]
    (map itoc (between (ctoi c1) (ctoi c2)))))

(define $c.between?
  (lambda [$c1 $c2 $c]
    (and (gte? (ctoi c) (ctoi c1))
         (lte? (ctoi c) (ctoi c2)))))

(define $alphabet?
  (lambda [$c]
    (or (c.between? c#a c#z c)
        (c.between? c#A c#Z c))))

(define $alphabets?
  (lambda [$s]
    (all alphabet? (unpack s))))

(define $upper-case
  (lambda [$c]
    (if (c.between? c#a c#z c)
      (itoc (- (ctoi c) 32))
      c)))

(define $lower-case
  (lambda [$c]
    (if (c.between? c#A c#Z c)
      (itoc (+ (ctoi c) 32))
      c)))
