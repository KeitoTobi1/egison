SH.genInput sopts copts := do
  let eof := isEof ()
  if eof
    then return []
    else do let line := readLine ()
            return (let x := TSV.parseLine sopts copts line
                     in seq x (x :: SH.genInput sopts copts))

TSV.map fn showFn := do
  let eof := isEof ()
  if eof
     then return ()
     else do let line := readLine ()
             print (showFn (fn (readTsv line)))
             TSV.map fn showFn

TSV.filter fn := do
  let eof := isEof ()
  if eof
     then return ()
     else do let line := readLine ()
             if fn (readTsv line) then print line else return ()
             TSV.filter fn

TSV.parseLine sopts copts line :=
  readTsv (S.intercalate "\t" (fnC copts (fnS sopts (S.split "\t" line))))
    where
      fnS := \match as (list (list integer), list string) with
               | ([$m] :: $opts', $xs) ->
                 let (hs, ts) := splitAt (m - 1) xs
                  in fnS opts' (hs ++ map (\t -> S.concat ["\"", t, "\""]) ts)
               | ([$m, #m] :: $opts', $xs) ->
                 let (hs, ts') := splitAt (m - 1) xs
                     (mf, ts)  := uncons ts'
                  in fnS opts' (hs ++ S.concat ["\"", mf, "\""] :: ts)
               | ([$m, $n] :: $opts', $xs) ->
                 let (hs, ts') := splitAt (m - 1) xs
                     (ms, ts)  := splitAt (n - m + 1) ts'
                  in fnS opts' (hs ++ map (\m -> S.concat ["\"", m, "\""]) ms ++ ts)
               | ([$m, _] :: $opts', $fs) -> fnS ([m] :: opts') fs
               | (_, $fs) -> fs
      fnC := \match as (list (list integer), list string) with
               | ([$m] :: $opts', $xs) ->
                 let (hs, ts) := splitAt (m - 1) xs
                  in fnC opts' (hs ++ [S.concat ["[", S.intercalate ", " ts, "]"]])
               | ([$m, #m] :: $opts', $xs) ->
                 let (hs, ts') := splitAt (m - 1) xs
                     (mf, ts)  := uncons ts'
                  in fnC opts' (hs ++ S.concat ["[", mf, "]"] :: ts)
               | ([$m, $n] :: $opts', $xs) ->
                 let (hs, ts') := splitAt (m - 1) xs
                     (ms, ts)  := splitAt (n - m + 1) ts'
                  in fnC opts' (hs ++ S.concat ["[", S.intercalate ", " ms, "]"] :: ts)
               | ([$m, _] :: $opts', $fs) -> fnC ([m] :: opts') fs
               | (_, $fs) -> fs

TSV.show := showTsv
