--
--
-- Term Rewriting
--
--

mathNormalize $x :=
  if isInteger x
    then x
    else (foldr compose id (map 2#%1 (filter 2#(%2 x) rewriteRules))) (symbolNormalize x)

rewriteRules :=
  [ (rewriteRuleForRtu, 1#(containFunction `rtu %1))
  , (rewriteRuleForSqrt, 1#(containFunction `sqrt %1))
  , (rewriteRuleForRt, 1#(containFunction `rt %1))
  , (rewriteRuleForSin, 1#(containFunction `sin %1))
  , (rewriteRuleForCosToSin, 1#(containFunctionWithOrder `cos 2 %1))
  , (rewriteRuleForD/d, 1#True) ]

--
-- rtu (include i and w)
--
rewriteRuleForRtu :=
  compose
    1#(mapTerms rewriteRuleForRtuTerm %1)
    1#(mapPolys rewriteRuleForRtuPoly %1)
  where
    rewriteRuleForRtuTerm := 1#(mapTerms rewriteRuleForRtuTerm' %1)
    rewriteRuleForRtuTerm' term :=
      match term as mathExpr with
        | $a * #`rtu $n ^ (?(>= n) & $k) * $r -> a *' rtu n ^' (k % n) *' r
        | _ -> term

    rewriteRuleForRtuPoly := 1#(mapPolys rewriteRuleForRtuPoly' %1)
    rewriteRuleForRtuPoly' poly :=
      match poly as mathExpr with
        | $a * #rtu $n ^ #1 * $mr + (loop $i (2, #(n - 1))
                                       (#a * #(rtu n) ^ #i * #mr + ...)
                                       $pr) ->
          rewriteRuleForRtuPoly' (pr +' (-1) *' a *' mr)
        | _ -> poly

--
-- sqrt
--
rewriteRuleForSqrt := 1#(mapTerms rewriteRuleForSqrtTerm %1)
  where
    rewriteRuleForSqrtTerm term :=
      match term as mathExpr with
        | $a * #`sqrt $x * #`sqrt #x * $r ->
          rewriteRuleForSqrt (a *' x *' r)
        | $a * #`sqrt (?isTerm & $x) * #`sqrt (?isTerm & $y) * $r ->
          let d := gcd x y
              (a1, x1) := fromMonomial (x / d)
              (a2, y1) := fromMonomial (y / d)
           in a *' d *' sqrt (a1 *' a2) *' sqrt x1 *' sqrt y1 *' r
        | _ -> term

--
-- rt (include sqrt)
--
rewriteRuleForRt := 1#(mapTerms rewriteRuleForRtTerm %1)
  where
    rewriteRuleForRtTerm term :=
      match term as mathExpr with
        | $a * #`rt $n $x ^ (?(>= n) & $k) * $r ->
          a *' x ^' quotient k n *' rt n x ^' (k % n) *' r
        | _ -> term

--
-- cos, sin
--
rewriteRuleForCosToSin := 1#(mapTerms rewriteRuleForCosToSinTerm' %1)
  where
    rewriteRuleForCosToSinTerm' term :=
      match term as mathExpr with
        | $a * #`cos $x ^ #2 * $mr ->
          a *' (1 -' sin x ^ 2) *' rewriteRuleForCosToSinTerm' mr
        | _ -> term

rewriteRuleForSin mExpr := mapTerms f mExpr
  where
    f term :=
      match term as mathExpr with
        | $a * #`sin (mult $n #Ï€ / #2) * $mr ->
          a *' (-1) ^ ((abs n - 1) / 2) *' mr
        | _ -> term

--
-- d/d
--
rewriteRuleForD/d := 1#(mapPolys rewriteRuleForD/dPoly %1)
  where
    rewriteRuleForD/dPoly poly :=
      match poly as mathExpr with
        | $a * ($f & (func $g _ $arg $js)) ^ $n * $mr +
            $b * func #g _ #arg ?1#(eqAs (multiset something) js %1) ^ #n * #mr +
              $pr ->
          rewriteRuleForD/dPoly ((a + b) *' f ^ n *' mr +' pr)
        | _ -> poly
