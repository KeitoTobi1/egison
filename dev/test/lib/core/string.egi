assert("string's value pattern",
  match "abc" as string
  | "abc" -> #t
  | _ -> #f)

assert("string's nil - case 1",
  match "" as string
  | <nil> -> #t
  | _ -> #f)

assert("string's nil - case 2",
  match "abc" as string
  | <nil> -> #f
  | _ -> #t)

assertEqual("string's cons",
  matchAll "abc" as string
  | $x<:>$xs -> [x, xs],
  [[c#a, "bc"]])

assertEqual("string's join",
  matchAll "abc" as string
  | $xs<++>$ys -> [xs, ys],
  [["", "abc"], ["a", "bc"],
   ["ab", "c"], ["abc", ""]])

;;;
;;; string as collection
;;;
assertEqual("s.empty? - case 1",
  s.empty?(""),
  #t)

assertEqual("s.empty? - case 2",
  s.empty?("Egison"),
  #f)

assertEqual("s.car",
  s.car("Egison"),
  c#E)

assertEqual("s.cdr",
  s.cdr("Egison"),
  "gison")

assertEqual("s.rac",
  s.rac("Egison"),
  c#n)

assertEqual("s.map",
  s.map(id, "Egison"),
  "Egison")

assertEqual("s.length",
  s.length("Egison"),
  6)

assertEqual("s.split",
  s.split(",", "Lisp,Haskell,Egison"),
  ["Lisp", "Haskell", "Egison"])

assertEqual("s.append",
  s.append("Egi", "son"),
  "Egison")

assertEqual("s.concat",
  s.concat(["Egi", "son"]),
  "Egison")

assertEqual("s.intercalate",
  s.intercalate(",", ["Lisp", "Haskell", "Egison"]),
  "Lisp,Haskell,Egison")

;;
;; Characters
;;
assertEqual("alphabet?",
  alphabet?(c#a),
  #t)

assertEqual("alphabets?",
  alphabets?("Egison"),
  #t)

assertEqual("upper-case",
  upperCase(c#e),
  c#E)

assertEqual("lower-case",
  lowerCase(c#E),
  c#e)
