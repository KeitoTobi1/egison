N := 5

tree a := matcher
  | node $ $ as (a, multiset (tree a)) with
    | Node $x $ts -> [(x, ts)]
  | $ as something with
    | $tgt -> [tgt]

state := (integer, multiset integer, multiset integer)

move s := matchAllDFS s as (integer, list integer, list integer) with
  | (#1, $hs ++ $x :: (!(_ ++ #x :: _) & $ts), $hs' ++ (?(\y -> x + y < N + 1) & $y) :: (!(_ ++ #y :: _) & $ts'))
  -> (2, hs ++ x :: ts, hs' ++ x + y :: ts')
  | (#1, $hs ++ $x :: (!(_ ++ #x :: _) & $ts), ?(\y -> x + y > N) :: [])
  -> (-1, hs ++ x :: ts, [])
  | (#1, $hs ++ $x :: (!(_ ++ #x :: _) & $ts), (!(_ :: []) & $hs' ++ (?(\y -> x + y > N) & $y) :: (!(_ ++ #y :: _) & $ts')))
  -> (2, hs ++ x :: ts, hs' ++ ts')
  | (#2, $hs ++ $x :: (!(_ ++ #x :: _) & $ts), $hs' ++ (?(\y -> x + y < N + 1) & $y) :: (!(_ ++ #y :: _) & $ts'))
  -> (1, hs ++ x + y :: ts, hs' ++ y :: ts')
  | (#2, $x :: [], $hs' ++ (?(\y -> x + y > N) & $y) :: (!(_ ++ #y :: _) & $ts'))
  -> (-2, [], hs' ++ y :: ts')
  | (#2, !(_ :: []) & $hs ++ $x :: (!(_ ++ #x :: _) & $ts), $hs' ++ (?(\y -> x + y > N) & $y) :: (!(_ ++ #y :: _) & $ts'))
  -> (1, hs ++ ts, hs' ++ y :: ts')

init := (1, [1,1], [1,1])

next := car (move init) -- (2, [1, 1], [1, 2])

makeTree x := Node x (map makeTree (move x))

topTree n :=
  matchAllDFS makeTree init as tree state with
  | loop $i (1, n)
      (node $x_i (... :: _))
      _
  -> map (\i -> x_i) [1..n]

--io (each (compose show print) (topTree 5))

paths :=
  matchAllDFS makeTree init as tree state with
  | loop $i (1, $n)
      (node $x_i (... :: _))
      (node $x_(n + 1) [])
  -> map (\i -> x_i) [1..(n + 1)]

--io (each (compose show print) (car paths))

winningRec s :=
  matchAll makeTree s as tree state with
  | (node ($h, _, _)
         ((node ($t & ((#(neg h), _, _)
                    | ?(\t -> (empty? (winningRec t))))) _)
          :: _))
  -> t

winning s :=
  matchAll makeTree s as tree state with
  | (node ($h, _, _)
      ((loop $i (1, [1..], _)
         (node $t !(node _ !(... :: _) :: _))
         (node (#(neg h), _, _) _)) :: _))
  -> t

winningRec (1, [1, 1], [1, 1])
winningRec (2, [1, 1], [1, 2])

winning (1, [1, 1], [1, 1])
winning (2, [1, 1], [1, 2])

